<!doctype html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Text Adder â€” Popup Styling</title>

  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- Color picker library -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>

  <style>
    *{ box-sizing:border-box; font-family:'Inter',system-ui,-apple-system,'Segoe UI',Roboto,Arial; }
    html,body{ height:100%; margin:0; background: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), url('images/background.jpg'); color:#e6eef8; }
    body{ display:flex; align-items:flex-start; justify-content:center; padding:28px; }

    .container{
      width:100%; max-width:980px; background:rgba(255,255,255,0.06);
      backdrop-filter: blur(10px); border-radius:16px; padding:20px 22px 160px;
      border:1px solid rgba(255,255,255,0.06); box-shadow:0 12px 40px rgba(0,0,0,0.6);
      min-height: 60px;
    }

    .header{ display:flex; align-items:center; gap:12px; margin-bottom:12px; }
    .header h1{ margin:0; font-size:20px; font-weight:700; color:#fff; display:flex; gap:10px; align-items:center;}
    .header i{ color:#60a5fa; font-size:26px; }

    .upload-area{
      border:2px dashed rgba(255,255,255,0.18); padding:20px; border-radius:12px; text-align:center; cursor:pointer; background:rgba(255,255,255,0.02);
      margin-bottom:14px; position:relative;
    }
    .upload-area:hover{ border-color:#60a5fa; background:rgba(96,165,250,0.04); }
    .upload-area i{ font-size:34px; color:#60a5fa; display:block; margin-bottom:8px; }
    .upload-area input[type=file]{ position:absolute; inset:0; width:100%; height:100%; opacity:0; cursor:pointer; }

    .preview-list{ display:flex; flex-direction:column; gap:18px; padding-right:6px; }

    .preview-item{ background:rgba(255,255,255,0.02); border-radius:10px; padding:12px; display:flex; flex-direction:column; align-items:center; }
    .preview-item h3{ margin:0 0 8px; color:#cfe8ff; font-weight:700; width:100%; text-align:left; }

    .canvas-wrap{ position:relative; width:100%; display:flex; justify-content:center; }
    canvas{ width:100% !important; height:auto !important; border-radius:6px; box-shadow:0 8px 30px rgba(0,0,0,0.6); background:white; display:block; }

    .text-layer{ position:absolute; left:0; top:0; pointer-events:auto; }

    .text-element{ 
      position:absolute; cursor:move; touch-action:none; user-select:none; 
      display:flex; align-items:center; transition:transform 120ms ease;
      padding: 4px 8px; border-radius: 4px; background: rgba(0,0,0,0.05);
      border: 2px solid transparent;
      max-width: 300px;
      word-wrap: break-word;
    }
    .text-element.selected{ border-color: #60a5fa; background: rgba(96,165,250,0.1); }
    .text-element.pulse{ animation: textPulse 360ms ease; }
    @keyframes textPulse { 0% { transform: scale(1); } 50% { transform: scale(1.06); } 100% { transform: scale(1); } }

    .text-content{ 
      pointer-events:none; font-family: Arial, sans-serif;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .delete-btn{ 
      position:absolute; right:-10px; top:-10px; width:26px; height:26px; 
      background:#ef4444; color:white; border-radius:50%; border:none;
      display:flex; align-items:center; justify-content:center; cursor:pointer;
      z-index: 10;
    }

    /* Text Editor Popup */
    .text-editor-popup {
      position: absolute;
      background: rgba(30, 30, 35, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.15);
      z-index: 10000;
      display: none;
      min-width: 320px;
      animation: popupFade 0.2s ease;
    }
    @keyframes popupFade {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .popup-header h3 {
      margin: 0;
      color: white;
      font-size: 16px;
      font-weight: 600;
    }

    .close-popup {
      background: none;
      border: none;
      color: rgba(255,255,255,0.7);
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    .close-popup:hover {
      background: rgba(255,255,255,0.1);
      color: white;
    }

    .text-input-container {
      margin-bottom: 16px;
    }

    .text-input-container textarea {
      width: 100%;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 12px;
      color: white;
      font-size: 14px;
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    .style-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-row label {
      color: rgba(255,255,255,0.9);
      font-size: 13px;
      font-weight: 500;
      min-width: 60px;
    }

    .control-row input[type="number"] {
      width: 70px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 8px;
      color: white;
      text-align: center;
    }

    .control-row input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 6px;
      overflow: hidden;
    }

    .font-style-buttons {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .style-btn {
      width: 36px;
      height: 36px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .style-btn:hover {
      background: rgba(255,255,255,0.15);
    }
    .style-btn.active {
      background: #60a5fa;
      border-color: #60a5fa;
      color: white;
    }

    .popup-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .action-btn {
      padding: 10px 20px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .cancel-btn {
      background: rgba(255,255,255,0.08);
      color: white;
    }
    .cancel-btn:hover {
      background: rgba(255,255,255,0.15);
    }

    .apply-btn {
      background: #60a5fa;
      color: white;
    }
    .apply-btn:hover {
      background: #3b82f6;
    }

    .floating-btn{
      position:fixed; left:50%; transform:translateX(-50%); bottom:18px; z-index:9999;
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(10px) saturate(1.05);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 12px 30px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.04);
      color: white; padding:12px 28px; border-radius:999px; font-weight:800; cursor:pointer; display:flex; gap:10px; align-items:center;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
    }
    .floating-btn:hover{ transform:translateX(-50%) translateY(-4px); box-shadow:0 18px 44px rgba(0,0,0,0.6); background: rgba(255,255,255,0.08); }
    .floating-btn:disabled{ opacity:0.6; cursor:not-allowed; }

    .progress{ position:fixed; left:50%; transform:translateX(-50%); bottom:78px; width:420px; height:8px; background:rgba(255,255,255,0.04); border-radius:8px; overflow:hidden; display:none; z-index:9998; }
    .progress > div{ width:0%; height:100%; background:linear-gradient(90deg,#5b86e5,#36d1dc); transition:width 200ms linear; }

    .footer-note{ margin-top:12px; color:rgba(255,255,255,0.6); font-size:13px; text-align:center; }

    @media (max-width:760px){
      .container{ padding-bottom:220px; }
      .progress{ width:86%; }
      .floating-btn{ width:86%; left:50%; transform:translateX(-50%); }
      .text-editor-popup {
        min-width: 280px;
        left: 10px !important;
        right: 10px !important;
        transform: none !important;
      }
    }

    /* Fix for spectrum color picker positioning */
    .sp-container { 
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      z-index: 10001 !important;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="header">
      <i class="fas fa-font"></i>
      <h1>PDF Text Adder</h1>
    </div>

    <div class="upload-area" id="uploadArea">
      <i class="fas fa-cloud-upload-alt"></i>
      <h3>Upload a PDF</h3>
      <p>Select a PDF and click anywhere on the pages to add text. A popup will appear for styling.</p>
      <input id="pdfInput" type="file" accept="application/pdf">
    </div>

    <div class="preview-list" id="previewList" aria-live="polite"></div>

    <div class="footer-note">Click anywhere on a page to add text. Drag to reposition. Double-click text to edit.</div>
  </div>

  <!-- Text Editor Popup -->
  <div class="text-editor-popup" id="textEditorPopup">
    <div class="popup-header">
      <h3>Edit Text</h3>
      <button class="close-popup" id="closePopupBtn">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="text-input-container">
      <textarea id="popupTextInput" placeholder="Enter your text here...">Sample Text</textarea>
    </div>
    
    <div class="style-controls">
      <div class="control-row">
        <label>Font+</label>
        <input type="number" id="popupFontSize" min="8" max="72" value="16">
      </div>
      
      <div class="control-row">
        <label>Color</label>
        <input type="text" id="popupColorPicker" value="#000000">
      </div>
      
      <div class="control-row">
        <label>Style</label>
        <div class="font-style-buttons">
          <button class="style-btn" id="boldBtn" title="Bold">
            <i class="fas fa-bold"></i>
          </button>
          <button class="style-btn" id="italicBtn" title="Italic">
            <i class="fas fa-italic"></i>
          </button>
          <button class="style-btn" id="underlineBtn" title="Underline">
            <i class="fas fa-underline"></i>
          </button>
        </div>
      </div>
    </div>
    
    <div class="popup-actions">
      <button class="action-btn cancel-btn" id="cancelBtn">Cancel</button>
      <button class="action-btn apply-btn" id="applyBtn">Apply</button>
    </div>
  </div>

  <div class="progress" id="progress"><div id="progressBar"></div></div>
  <button class="floating-btn" id="generateBtn" disabled><i class="fas fa-download"></i> Generate PDF with Text</button>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  const pdfInput = document.getElementById('pdfInput');
  const uploadArea = document.getElementById('uploadArea');
  const previewList = document.getElementById('previewList');
  const generateBtn = document.getElementById('generateBtn');
  const progress = document.getElementById('progress');
  const progressBar = document.getElementById('progressBar');
  const container = document.getElementById('container');
  
  // Text Editor Popup Elements
  const textEditorPopup = document.getElementById('textEditorPopup');
  const popupTextInput = document.getElementById('popupTextInput');
  const popupFontSize = document.getElementById('popupFontSize');
  const popupColorPicker = document.getElementById('popupColorPicker');
  const boldBtn = document.getElementById('boldBtn');
  const italicBtn = document.getElementById('italicBtn');
  const underlineBtn = document.getElementById('underlineBtn');
  const closePopupBtn = document.getElementById('closePopupBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const applyBtn = document.getElementById('applyBtn');

  const DPR = window.devicePixelRatio || 1;
  let selectedPdfFile = null;
  let pdfLibDoc = null;
  let pdfJsDoc = null;
  let pageData = [];
  let originalFilename = '';
  let selectedTextElement = null;
  let popupPosition = { x: 0, y: 0 };
  let isCreatingNewText = false;

  // Initialize color picker
  $(popupColorPicker).spectrum({
    type: "color",
    showInput: true,
    showInitial: true,
    allowEmpty: false,
    showAlpha: false,
    preferredFormat: "hex",
    containerClassName: 'spectrum-container',
    move: function(color) {
      updateTextPreview();
    },
    change: function(color) {
      updateTextPreview();
    }
  });

  // Default text style
  const defaultTextStyle = {
    text: "Sample Text",
    fontSize: 16,
    color: "#000000",
    bold: false,
    italic: false,
    underline: false
  };
  
  // Current text style for editing
  let currentTextStyle = {...defaultTextStyle};

  // Style buttons toggle
  boldBtn.addEventListener('click', () => {
    boldBtn.classList.toggle('active');
    currentTextStyle.bold = boldBtn.classList.contains('active');
    updateTextPreview();
  });

  italicBtn.addEventListener('click', () => {
    italicBtn.classList.toggle('active');
    currentTextStyle.italic = italicBtn.classList.contains('active');
    updateTextPreview();
  });

  underlineBtn.addEventListener('click', () => {
    underlineBtn.classList.toggle('active');
    currentTextStyle.underline = underlineBtn.classList.contains('active');
    updateTextPreview();
  });

  // Update text preview in real-time
  function updateTextPreview() {
    if (!selectedTextElement) return;
    
    const textContent = selectedTextElement.querySelector('.text-content');
    textContent.textContent = popupTextInput.value;
    textContent.style.fontSize = currentTextStyle.fontSize + 'px';
    textContent.style.color = currentTextStyle.color;
    textContent.style.fontWeight = currentTextStyle.bold ? 'bold' : 'normal';
    textContent.style.fontStyle = currentTextStyle.italic ? 'italic' : 'normal';
    textContent.style.textDecoration = currentTextStyle.underline ? 'underline' : 'none';
    
    // Update text data
    const pageIndex = selectedTextElement.dataset.pageIndex;
    const textId = selectedTextElement.dataset.textId;
    const pd = pageData[pageIndex];
    
    if (!pd || !pd.texts) return;
    
    const textData = pd.texts.find(t => t.id === textId);
    if (!textData) return;
    
    textData.text = popupTextInput.value;
    textData.fontSize = currentTextStyle.fontSize;
    textData.color = currentTextStyle.color;
    textData.bold = currentTextStyle.bold;
    textData.italic = currentTextStyle.italic;
    textData.underline = currentTextStyle.underline;
  }

  // Show text editor popup
  function showTextEditor(x, y, textData = null, isNew = false) {
    isCreatingNewText = isNew;
    
    // Position popup near click/target position
    const popupWidth = textEditorPopup.offsetWidth || 320;
    const popupHeight = textEditorPopup.offsetHeight || 400;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Adjust position to stay within viewport
    let posX = x;
    let posY = y;
    
    if (x + popupWidth > viewportWidth - 20) {
      posX = viewportWidth - popupWidth - 20;
    }
    if (y + popupHeight > viewportHeight - 20) {
      posY = viewportHeight - popupHeight - 20;
    }
    
    textEditorPopup.style.left = posX + 'px';
    textEditorPopup.style.top = posY + 'px';
    textEditorPopup.style.display = 'block';
    
    popupPosition = { x: posX, y: posY };
    
    // Set values based on textData or defaults
    if (textData) {
      popupTextInput.value = textData.text;
      popupFontSize.value = textData.fontSize;
      $(popupColorPicker).spectrum("set", textData.color);
      boldBtn.classList.toggle('active', textData.bold);
      italicBtn.classList.toggle('active', textData.italic);
      underlineBtn.classList.toggle('active', textData.underline);
      
      currentTextStyle = {
        text: textData.text,
        fontSize: textData.fontSize,
        color: textData.color,
        bold: textData.bold,
        italic: textData.italic,
        underline: textData.underline
      };
    } else {
      // Use current style for new text
      popupTextInput.value = currentTextStyle.text;
      popupFontSize.value = currentTextStyle.fontSize;
      $(popupColorPicker).spectrum("set", currentTextStyle.color);
      boldBtn.classList.toggle('active', currentTextStyle.bold);
      italicBtn.classList.toggle('active', currentTextStyle.italic);
      underlineBtn.classList.toggle('active', currentTextStyle.underline);
    }
    
    // Focus on text input
    setTimeout(() => {
      popupTextInput.focus();
      popupTextInput.select();
    }, 10);
  }

  // Hide text editor popup
  function hideTextEditor() {
    textEditorPopup.style.display = 'none';
    
    // If we were creating a new text and cancelled, remove the temporary text element
    if (isCreatingNewText && selectedTextElement) {
      const pageIndex = selectedTextElement.dataset.pageIndex;
      const textId = selectedTextElement.dataset.textId;
      const pd = pageData[pageIndex];
      
      if (pd && pd.texts) {
        pd.texts = pd.texts.filter(t => t.id !== textId);
        selectedTextElement.remove();
        selectedTextElement = null;
        
        // Update generate button state
        generateBtn.disabled = pageData.every(pd => !pd.texts || pd.texts.length === 0);
      }
    }
    
    isCreatingNewText = false;
  }

  // Event listeners for popup
  popupTextInput.addEventListener('input', () => {
    currentTextStyle.text = popupTextInput.value;
    updateTextPreview();
  });

  popupFontSize.addEventListener('input', () => {
    currentTextStyle.fontSize = parseInt(popupFontSize.value) || 16;
    updateTextPreview();
  });

  closePopupBtn.addEventListener('click', hideTextEditor);
  cancelBtn.addEventListener('click', hideTextEditor);

  applyBtn.addEventListener('click', () => {
    hideTextEditor();
    // If creating new text, finalize it
    if (isCreatingNewText && selectedTextElement) {
      // Remove selection border
      selectedTextElement.classList.remove('selected');
      selectedTextElement = null;
    }
    isCreatingNewText = false;
  });

  // Close popup when clicking outside
  document.addEventListener('click', (e) => {
    if (textEditorPopup.style.display === 'block' && 
        !textEditorPopup.contains(e.target) && 
        !e.target.classList.contains('text-element') &&
        !e.target.closest('.text-element')) {
      hideTextEditor();
    }
  });

  // Drag/drop UI for PDF upload
  ['dragenter','dragover'].forEach(ev => uploadArea.addEventListener(ev, e=>{ 
    e.preventDefault(); 
    uploadArea.style.borderColor = '#60a5fa';
    uploadArea.style.background = 'rgba(96,165,250,0.08)';
  }));
  
  ['dragleave','drop'].forEach(ev => uploadArea.addEventListener(ev, e=>{ 
    e.preventDefault(); 
    uploadArea.style.borderColor = 'rgba(255,255,255,0.18)';
    uploadArea.style.background = 'rgba(255,255,255,0.02)';
  }));
  
  uploadArea.addEventListener('drop', e=> { 
    if(e.dataTransfer?.files?.length) {
      handlePdf(e.dataTransfer.files[0]);
    }
  });

  pdfInput.addEventListener('change', (e)=> { 
    if(e.target.files?.length) {
      handlePdf(e.target.files[0]);
      originalFilename = e.target.files[0].name.replace(/\.pdf$/i, '');
    }
  });

  async function handlePdf(file){
    if(!file) return;
    if(file.type !== 'application/pdf'){ 
      alert('Please upload a PDF file'); 
      return; 
    }
    
    selectedPdfFile = file;
    previewList.innerHTML = '';
    pageData = [];
    selectedTextElement = null;
    generateBtn.disabled = true;
    hideTextEditor(); // Hide any open popup

    try{
      const ab = await file.arrayBuffer();
      pdfLibDoc = await PDFLib.PDFDocument.load(ab);
      pdfJsDoc = await pdfjsLib.getDocument({data: ab}).promise;
      const total = pdfLibDoc.getPageCount();

      // Measure container inner width
      const cs = getComputedStyle(container);
      const padLeft = parseFloat(cs.paddingLeft || 20);
      const padRight = parseFloat(cs.paddingRight || 20);
      const availableWidth = Math.max(300, container.clientWidth - padLeft - padRight - 4);

      for(let p = 1; p <= total; p++){
        const page = await pdfJsDoc.getPage(p);
        const base = page.getViewport({scale:1});
        const scale = (availableWidth / base.width);
        const viewport = page.getViewport({scale});
        const cssW = Math.round(viewport.width);
        const cssH = Math.round(viewport.height);

        const canvas = document.createElement('canvas');
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.floor(cssW * DPR);
        canvas.height = Math.floor(cssH * DPR);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(DPR,0,0,DPR,0,0);
        await page.render({ canvasContext: ctx, viewport }).promise;

        const libPage = pdfLibDoc.getPage(p-1);
        const psize = libPage.getSize();

        const item = document.createElement('div');
        item.className = 'preview-item';
        const title = document.createElement('h3');
        title.textContent = `Page ${p}`;
        item.appendChild(title);

        const wrap = document.createElement('div');
        wrap.className = 'canvas-wrap';
        wrap.style.width = cssW + 'px';
        wrap.style.height = cssH + 'px';
        wrap.appendChild(canvas);

        // Text layer
        const layer = document.createElement('div');
        layer.className = 'text-layer';
        layer.style.width = cssW + 'px';
        layer.style.height = cssH + 'px';
        layer.style.left = '0';
        layer.style.top = '0';
        layer.style.position = 'absolute';
        wrap.style.position = 'relative';
        wrap.appendChild(layer);

        item.appendChild(wrap);
        previewList.appendChild(item);

        pageData[p-1] = {
          pdfSize: { width: psize.width, height: psize.height },
          viewport: { width: viewport.width, height: viewport.height },
          canvasElem: canvas,
          layerElem: layer,
          wrapElem: wrap,
          texts: []
        };

        // Click on layer to add text
        layer.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          
          const rect = layer.getBoundingClientRect();
          const clickX = ev.clientX;
          const clickY = ev.clientY;
          
          // Check if click is on existing text
          const existing = Array.from(layer.querySelectorAll('.text-element'));
          for(const el of existing){
            const br = el.getBoundingClientRect();
            
            if(clickX >= br.left && clickX <= br.right && clickY >= br.top && clickY <= br.bottom){
              // Select existing text
              selectTextElement(el);
              showTextEditor(clickX + 10, clickY + 10, getTextDataFromElement(el), false);
              return;
            }
          }
          
          // Add new text
          const layerX = ev.clientX - rect.left;
          const layerY = ev.clientY - rect.top;
          addTextToPage(p-1, layerX, layerY, clickX, clickY);
        });
        
        // Double-click text to edit
        layer.addEventListener('dblclick', (ev) => {
          const target = ev.target;
          const textEl = target.closest('.text-element');
          if (textEl) {
            selectTextElement(textEl);
            showTextEditor(ev.clientX + 10, ev.clientY + 10, getTextDataFromElement(textEl), false);
          }
        });
      }

      generateBtn.disabled = pageData.every(pd => !pd.texts || pd.texts.length === 0);
      previewList.scrollIntoView({ behavior: 'smooth', block: 'start' });

    } catch(err) {
      console.error('PDF load/render error', err);
      alert('Error loading PDF: ' + (err.message || 'Please check if the PDF file is valid'));
    }
  }

  function addTextToPage(pageIndex, x_css, y_css, clickX, clickY){
    const pd = pageData[pageIndex];
    if(!pd) return;
    const layer = pd.layerElem;
    const id = `text-${pageIndex}-${Date.now()}`;
    
    // Create text element
    const textEl = document.createElement('div');
    textEl.className = 'text-element selected';
    textEl.id = id;
    textEl.dataset.pageIndex = pageIndex;
    textEl.dataset.textId = id;
    
    // Position the text
    const left = x_css;
    const top = y_css;
    textEl.style.left = Math.max(0, left) + 'px';
    textEl.style.top = Math.max(0, top) + 'px';
    
    // Create text content
    const textContent = document.createElement('div');
    textContent.className = 'text-content';
    textContent.textContent = currentTextStyle.text;
    textContent.style.fontSize = currentTextStyle.fontSize + 'px';
    textContent.style.color = currentTextStyle.color;
    textContent.style.fontWeight = currentTextStyle.bold ? 'bold' : 'normal';
    textContent.style.fontStyle = currentTextStyle.italic ? 'italic' : 'normal';
    textContent.style.textDecoration = currentTextStyle.underline ? 'underline' : 'none';
    textEl.appendChild(textContent);
    
    // Delete button
    const del = document.createElement('button');
    del.className = 'delete-btn';
    del.innerHTML = '<i class="fas fa-trash"></i>';
    del.addEventListener('click', (e)=> {
      e.stopPropagation();
      if (selectedTextElement === textEl) {
        selectedTextElement = null;
        hideTextEditor();
      }
      textEl.remove();
      pd.texts = pd.texts.filter(t => t.id !== id);
      generateBtn.disabled = pageData.every(p=> p.texts.length===0);
    });
    textEl.appendChild(del);
    
    layer.appendChild(textEl);
    
    // Store text data
    const scaleX = pd.pdfSize.width / pd.viewport.width;
    const scaleY = pd.pdfSize.height / pd.viewport.height;
    const pdfX = left * scaleX;
    const pdfTop = top * scaleY;
    
    const stored = { 
      id, 
      x_pdf: pdfX, 
      top_pdf: pdfTop,
      text: currentTextStyle.text,
      fontSize: currentTextStyle.fontSize,
      color: currentTextStyle.color,
      bold: currentTextStyle.bold,
      italic: currentTextStyle.italic,
      underline: currentTextStyle.underline
    };
    pd.texts.push(stored);
    
    // Make draggable
    makeDraggable(textEl, pageIndex, stored);
    
    // Select this new text
    selectTextElement(textEl);
    
    // Show popup for editing
    showTextEditor(clickX + 10, clickY + 10, stored, true);
    
    generateBtn.disabled = false;
  }

  function selectTextElement(element) {
    // Deselect previous
    if (selectedTextElement && selectedTextElement !== element) {
      selectedTextElement.classList.remove('selected');
    }
    
    // Select new
    selectedTextElement = element;
    element.classList.add('selected');
  }

  function getTextDataFromElement(element) {
    const pageIndex = element.dataset.pageIndex;
    const textId = element.dataset.textId;
    const pd = pageData[pageIndex];
    
    if (!pd || !pd.texts) return null;
    
    return pd.texts.find(t => t.id === textId);
  }

  function makeDraggable(domEl, pageIndex, stored){
    let dragging = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;
    const layer = pageData[pageIndex].layerElem;

    const down = (e) => {
      e.preventDefault();
      dragging = true;
      const cx = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
      const cy = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
      startX = cx; 
      startY = cy;
      startLeft = parseFloat(domEl.style.left || 0);
      startTop = parseFloat(domEl.style.top || 0);
      
      // Select this element when starting to drag
      selectTextElement(domEl);
      
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', up);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', up);
    };

    const move = (e) => {
      if(!dragging) return;
      e.preventDefault();
      const cx = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
      const cy = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
      const dx = cx - startX, dy = cy - startY;
      let newLeft = startLeft + dx, newTop = startTop + dy;
      
      // Constrain within layer
      newLeft = Math.max(0, Math.min(newLeft, layer.clientWidth - domEl.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, layer.clientHeight - domEl.offsetHeight));
      
      domEl.style.left = newLeft + 'px';
      domEl.style.top = newTop + 'px';

      const pd = pageData[pageIndex];
      const sX = pd.pdfSize.width / pd.viewport.width;
      const sY = pd.pdfSize.height / pd.viewport.height;
      stored.x_pdf = newLeft * sX;
      stored.top_pdf = newTop * sY;
    };

    const up = (e) => {
      dragging = false;
      document.removeEventListener('mousemove', move);
      document.removeEventListener('mouseup', up);
      document.removeEventListener('touchmove', move);
      document.removeEventListener('touchend', up);
    };

    domEl.addEventListener('mousedown', down);
    domEl.addEventListener('touchstart', down, {passive:false});
  }

  // Generate PDF with text
  generateBtn.addEventListener('click', async ()=>{
    if(!selectedPdfFile) { alert('Upload a PDF first'); return; }
    if(pageData.every(pd => !pd.texts || pd.texts.length===0)) { alert('Add at least one text element'); return; }
    
    try{
      generateBtn.disabled = true;
      progress.style.display = 'block';
      progressBar.style.width = '6%';

      const ab = await selectedPdfFile.arrayBuffer();
      progressBar.style.width = '18%';
      const pdfDoc = await PDFLib.PDFDocument.load(ab);
      progressBar.style.width = '36%';

      // Embed fonts (Helvetica with variants)
      const helveticaFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
      const helveticaBoldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
      const helveticaObliqueFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaOblique);
      const helveticaBoldObliqueFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBoldOblique);

      progressBar.style.width = '50%';

      const pages = pdfDoc.getPages();
      for(let i=0;i<pages.length;i++){
        const page = pages[i];
        const pd = pageData[i];
        if(!pd) continue;
        
        for(const t of pd.texts){
          // Convert hex color to RGB
          const hex = t.color.replace('#', '');
          const r = parseInt(hex.substr(0,2), 16) / 255;
          const g = parseInt(hex.substr(2,2), 16) / 255;
          const b = parseInt(hex.substr(4,2), 16) / 255;
          
          // Choose font based on style
          let font;
          if(t.bold && t.italic) {
            font = helveticaBoldObliqueFont;
          } else if(t.bold) {
            font = helveticaBoldFont;
          } else if(t.italic) {
            font = helveticaObliqueFont;
          } else {
            font = helveticaFont;
          }
          
          // Calculate Y position (PDF origin is bottom-left)
          const pdfY = pd.pdfSize.height - t.top_pdf - t.fontSize;
          
          page.drawText(t.text, {
            x: t.x_pdf,
            y: pdfY,
            size: t.fontSize,
            font: font,
            color: PDFLib.rgb(r, g, b)
          });
        }
      }
      
      progressBar.style.width = '86%';
      const out = await pdfDoc.save();
      progressBar.style.width = '96%';

      const blob = new Blob([out], { type:'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      
      const downloadFilename = originalFilename ? `${originalFilename}_with_text.pdf` : `document_with_text.pdf`;
      a.download = downloadFilename;
      
      document.body.appendChild(a);
      a.click();
      a.remove();
      progressBar.style.width = '100%';
      setTimeout(()=> { progress.style.display='none'; progressBar.style.width='0%'; }, 600);

      // Clear previews
      previewList.innerHTML = '';
      pageData = [];
      selectedPdfFile = null;
      originalFilename = '';
      selectedTextElement = null;
      hideTextEditor();
      generateBtn.disabled = true;
      
      // Reset to default style
      currentTextStyle = {...defaultTextStyle};
      
    }catch(err){
      console.error(err);
      alert('Error generating PDF with text: ' + (err.message || err));
      generateBtn.disabled = false;
      progress.style.display = 'none';
      progressBar.style.width = '0%';
    }
  });

  // Initialize with default style
  currentTextStyle = {...defaultTextStyle};
});
</script>
</body>
</html>
