<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Wave Audio Visualizer (Image-inspired)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  *{box-sizing:border-box;margin:0;padding:0;font-family:Inter,Segoe UI,Arial,sans-serif}
  body{background:#070711;color:#fff;min-height:100vh;padding:20px;display:flex;align-items:flex-start;justify-content:center}
  .container{max-width:1200px;width:100%}
  header{text-align:center;margin-bottom:18px}
  h1{font-size:1.6rem;background:linear-gradient(90deg,#ff8a00,#e52e71);-webkit-background-clip:text;background-clip:text;color:transparent}
  .app{display:grid;grid-template-columns:1fr 420px;gap:18px}
  @media(max-width:980px){.app{grid-template-columns:1fr}}
  .panel{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px}
  .upload-area{border:2px dashed rgba(255,255,255,0.05);padding:18px;border-radius:10px;text-align:center;cursor:pointer}
  .btn{background:linear-gradient(90deg,#ff8a00,#e52e71);border:none;padding:10px 14px;border-radius:999px;color:white;cursor:pointer;font-weight:600}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.08)}
  .small{font-size:0.9rem;color:#bfbfd9}
  canvas{width:100%;display:block;border-radius:12px;background:#03030a}
  video{width:100%;border-radius:8px;background:#000}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Neon Wave Audio Visualizer — Image inspired</h1>
      <p class="small">Multi-layer neon ribbons, glowing overlaps, rim circle and color sweep (blue→green→yellow→red). Records canvas+audio to WebM.</p>
    </header>

    <div class="app">
      <div class="panel">
        <h3>Upload & Controls</h3>

        <div id="uploadArea" class="upload-area">
          <i class="fas fa-file-audio" style="font-size:28px;color:rgba(255,255,255,0.6)"></i>
          <div style="margin-top:8px">Drag & drop audio or click to browse</div>
          <div style="margin-top:10px">
            <button id="browseBtn" class="btn"><i class="fas fa-folder-open"></i> Browse</button>
          </div>
          <input id="audioFile" type="file" accept="audio/*" style="display:none">
        </div>

        <div style="margin-top:12px" id="audioInfo" class="small" style="display:none">
          <div>File: <span id="fileName">-</span></div>
          <div>Duration: <span id="fileDuration">-</span> · Size: <span id="fileSize">-</span></div>
        </div>

        <div style="margin-top:12px">
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="generateBtn" class="btn"><i class="fas fa-play"></i> Generate & Record</button>
            <button id="stopBtn" class="btn secondary" disabled><i class="fas fa-stop"></i> Stop</button>
            <button id="downloadBtn" class="btn secondary" disabled><i class="fas fa-download"></i> Download</button>
          </div>
        </div>

        <div style="margin-top:12px" class="small">
          Background image path attempted: <code>/mnt/data/WhatsApp Image 2025-10-11 at 12.25.39 AM.jpeg</code>.
          If you want the photo visible behind the neon ribbons, place it next to the HTML and update the `bgImagePath` variable below if needed.
        </div>
      </div>

      <div class="panel">
        <h3>Visualizer & Preview</h3>
        <div style="background:#020214;padding:10px;border-radius:12px">
          <canvas id="canvas"></canvas>
        </div>
        <div style="margin-top:10px">
          <video id="recorded" controls playsinline></video>
        </div>
      </div>
    </div>
  </div>

<script>
/* Neon Wave Visualizer — aims to mimic the provided image: multiple glowing multicolor ribbons */
document.addEventListener('DOMContentLoaded', ()=>{

  // === DOM refs
  const canvas = document.getElementById('canvas');
  const browseBtn = document.getElementById('browseBtn');
  const audioFile = document.getElementById('audioFile');
  const generateBtn = document.getElementById('generateBtn');
  const stopBtn = document.getElementById('stopBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const recorded = document.getElementById('recorded');
  const fileNameEl = document.getElementById('fileName');
  const fileDurationEl = document.getElementById('fileDuration');
  const fileSizeEl = document.getElementById('fileSize');
  const audioInfo = document.getElementById('audioInfo');

  // Try to load the image you provided (useful if available)
  const bgImagePath = '/mnt/data/WhatsApp Image 2025-10-11 at 12.25.39 AM.jpeg';
  const bgImg = new Image();
  let bgAvailable = false;
  bgImg.crossOrigin = 'anonymous';
  bgImg.onload = ()=>{ bgAvailable = true; console.log('bg image loaded'); };
  bgImg.onerror = ()=>{ bgAvailable = false; console.log('bg image not available'); };
  bgImg.src = bgImagePath;

  // audio + analyser
  let audioEl = null;
  let audioCtx = null;
  let analyser = null;
  let dataArray = null;
  let bufferLength = 0;
  let sourceNode = null;

  // drawing / recording
  const ctx = canvas.getContext('2d', {alpha:true});
  const dpr = window.devicePixelRatio || 1;
  let animFrame = null;

  // recording
  let mediaRecorder = null;
  let recordedChunks = [];

  // visual params (tweak to match image)
  const layers = 5; // number of ribbons
  const baseGlow = 28; // blur — increase for stronger glow
  const colors = [
    '#1850ff', // blue
    '#00f2fe', // cyan
    '#3bf34b', // greenish
    '#f7f32a', // yellow
    '#ff3b2e'  // red
  ];

  // responsive canvas
  function resize(){
    const parent = canvas.parentElement;
    const wCSS = parent.clientWidth - 0; // take full width
    let height = Math.round(wCSS * 9/40 * 3.2); // tall-ish strip similar to your image
    if (height < 180) height = 180;
    canvas.style.width = wCSS + 'px';
    canvas.style.height = height + 'px';
    canvas.width = Math.round(wCSS * dpr);
    canvas.height = Math.round(height * dpr);
  }
  window.addEventListener('resize', ()=>{ resize(); });

  // map a value
  function map(v, a, b, c, d){ return c + (v - a) * (d - c) / (b - a); }

  // init analyser on first user gesture
  function initAudioContext(){
    if (!audioEl) return false;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      bufferLength = analyser.fftSize;
      dataArray = new Uint8Array(bufferLength);
      sourceNode = audioCtx.createMediaElementSource(audioEl);
      sourceNode.connect(analyser);
      sourceNode.connect(audioCtx.destination);
    }
    return true;
  }

  // draw neon ribbons:
  // each ribbon is a smoothed sine-like curve across width, offset by phase.
  function draw(){
    if (!analyser) {
      // draw subtle ambient background if no analyser
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(6,6,12,0.18)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      animFrame = requestAnimationFrame(draw);
      return;
    }

    analyser.getByteTimeDomainData(dataArray);

    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background: either image or gradient
    if (bgAvailable){
      // draw image with low alpha so neon stands out
      const iw = bgImg.width, ih = bgImg.height;
      const scale = Math.max(canvas.width/iw, canvas.height/ih);
      const dw = iw*scale, dh = ih*scale;
      const dx = (canvas.width - dw)/2, dy = (canvas.height - dh)/2;
      ctx.globalAlpha = 0.14;
      ctx.drawImage(bgImg, dx, dy, dw, dh);
      ctx.globalAlpha = 1;
    } else {
      const g = ctx.createLinearGradient(0,0,canvas.width,0);
      g.addColorStop(0,'#001028'); g.addColorStop(0.25,'#002a49'); g.addColorStop(0.55,'#06280b'); g.addColorStop(0.85,'#2a0610'); g.addColorStop(1,'#200010');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // additive blend for strong neon overlap
    ctx.globalCompositeOperation = 'lighter';

    const now = performance.now() / 1000;
    const w = canvas.width;
    const h = canvas.height;
    const centerY = h * 0.5;

    // sample amplitude from audio data (use average of a band to drive intensity)
    let sum = 0;
    for (let i=0;i<bufferLength;i+=8) sum += Math.abs(dataArray[i] - 128);
    const avg = sum / (bufferLength/8);
    const globalAmp = map(avg, 0, 128, 0.02, 1.6);

    // draw layered ribbons from back (low) to front (high)
    for (let L = layers-1; L >= 0; L--){
      const layerRatio = L / (layers - 1);
      const hueIndex = Math.floor(layerRatio * (colors.length - 1));
      const c1 = colors[hueIndex];
      const c2 = colors[Math.min(hueIndex+1, colors.length-1)];

      // create long horizontal gradient for this layer
      const grad = ctx.createLinearGradient(0,0,w,0);
      grad.addColorStop(0, c1);
      grad.addColorStop(1, c2);

      ctx.strokeStyle = grad;
      // make thicker foreground strokes for nearer layers
      ctx.lineWidth = Math.max(1.2, (1.2 + (1 - layerRatio) * 6)) * dpr;
      // strong glow using shadow
      ctx.shadowColor = c2;
      ctx.shadowBlur = Math.max(6, baseGlow * (1 - layerRatio*0.9));
      ctx.globalAlpha = 0.9 * (0.6 + (1 - layerRatio) * 0.8);

      // path smoothing: use many sample points
      ctx.beginPath();
      const points = 160; // more = smoother
      let prevX = 0, prevY = centerY;
      for (let i = 0; i <= points; i++){
        const t = i / points;
        const x = t * w;
        // build a composite wave: base sin + audio-influenced jitter
        // pick an index into dataArray proportional to t
        const audioIndex = Math.floor(map(i, 0, points, 0, bufferLength-1));
        const audioVal = (dataArray[audioIndex] - 128) / 128; // -1..1
        // amplitude: widen toward center and modulate with audio
        const radial = Math.sin((t) * Math.PI); // 0..1..0
        const amp = (40 * (0.6 + layerRatio * 1.6) * radial + 8 * (1-layerRatio)) * dpr;
        // vary with time and index to create flowing motion
        const phase = now * (0.6 + layerRatio * 1.6) + t * (6 + layerRatio * 12);
        const wave = Math.sin(phase + t * Math.PI * 2 * (1 + layerRatio)) * (amp * (0.3 + globalAmp * 1.2) + audioVal * amp * 0.9);

        // vertical offset to stack ribbons across canvas height
        const offsetY = centerY + (layerRatio - 0.5) * h * 0.18 * (1 - layerRatio*0.6);

        const y = offsetY + wave;

        if (i === 0) ctx.moveTo(x, y);
        else {
          // use quadratic smoothing control points
          const cx = (prevX + x) / 2;
          ctx.quadraticCurveTo(prevX, prevY, cx, (prevY + y) / 2);
        }
        prevX = x; prevY = y;
      }
      ctx.stroke();

      // small faint fill / glow layer for thickness
      ctx.lineWidth = Math.max(1, ctx.lineWidth * 0.4);
      ctx.globalAlpha = 0.14 * (1 + (1 - layerRatio));
      ctx.stroke();
    }

    // rim circle highlight similar to image (top center)
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.12;
    ctx.lineWidth = 8 * dpr;
    ctx.strokeStyle = '#ffffff';
    ctx.shadowBlur = 0;
    const rimX = w * 0.5 + w * 0.02;
    const rimY = h * 0.15;
    const rimR = Math.min(w, h) * 0.13;
    ctx.beginPath();
    ctx.arc(rimX, rimY, rimR, -0.9, -0.1);
    ctx.stroke();

    // reset
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    animFrame = requestAnimationFrame(draw);
  }

  // ==== file handling & recording ====
  browseBtn.addEventListener('click', ()=> audioFile.click());
  uploadAreaEvents();

  audioFile.addEventListener('change', ()=> {
    if (!audioFile.files || !audioFile.files.length) return;
    const f = audioFile.files[0];
    const url = URL.createObjectURL(f);
    if (audioEl){
      audioEl.pause(); audioEl.src=''; audioEl = null;
    }
    audioEl = new Audio(url);
    audioEl.crossOrigin = 'anonymous';
    audioEl.preload = 'metadata';
    audioEl.addEventListener('loadedmetadata', ()=>{
      fileNameEl.textContent = f.name;
      fileDurationEl.textContent = formatTime(audioEl.duration);
      fileSizeEl.textContent = formatFileSize(f.size);
      audioInfo.style.display = 'block';
    });
  });

  function uploadAreaEvents(){
    const upload = document.getElementById('uploadArea');
    upload.addEventListener('dragover', e=>{ e.preventDefault(); upload.style.background='rgba(229,46,113,0.04)'; });
    upload.addEventListener('dragleave', e=>{ upload.style.background='transparent'; });
    upload.addEventListener('drop', e=>{ e.preventDefault(); upload.style.background='transparent'; audioFile.files = e.dataTransfer.files; const ev = new Event('change'); audioFile.dispatchEvent(ev); });
  }

  // generate -> start drawing + record
  generateBtn.addEventListener('click', async ()=>{
    if (!audioFile.files || !audioFile.files.length) { alert('Upload an audio file first'); return; }
    if (!audioEl) { alert('Audio not initialized'); return; }
    // ensure audio context created with user gesture
    initAudioContext();
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    resize();

    // start visual loop if not already
    if (!animFrame) {
      animFrame = requestAnimationFrame(draw);
    }

    // create recording streams: canvas + audio
    const canvasStream = canvas.captureStream(30);
    // create a MediaStreamDestination and connect sourceNode into it
    const dest = audioCtx.createMediaStreamDestination();
    try { sourceNode.connect(dest); } catch(e){ /* might already be connected; ignore */ }

    const combined = new MediaStream();
    canvasStream.getVideoTracks().forEach(t=>combined.addTrack(t));
    dest.stream.getAudioTracks().forEach(t=>combined.addTrack(t));

    // choose supported mime
    const preferred = (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) ? 'video/webm;codecs=vp9,opus' :
                      (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) ? 'video/webm;codecs=vp8,opus' : '';

    try {
      mediaRecorder = preferred ? new MediaRecorder(combined, { mimeType: preferred }) : new MediaRecorder(combined);
    } catch(err) {
      mediaRecorder = new MediaRecorder(combined);
    }

    recordedChunks = [];
    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordedChunks.push(e.data); };
    mediaRecorder.onstop = e => {
      const blob = new Blob(recordedChunks, { type: recordedChunks[0]?.type || 'video/webm' });
      const url = URL.createObjectURL(blob);
      recorded.src = url;
      recorded.play().catch(()=>{});
      downloadBtn.disabled = false;
      downloadBtn.onclick = ()=> {
        const a = document.createElement('a');
        a.href = url;
        const ext = blob.type.includes('mp4') ? 'mp4' : 'webm';
        a.download = `visualizer.${ext}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      };
    };

    mediaRecorder.start(1000); // chunk each second

    // play audio
    audioEl.currentTime = 0;
    audioEl.play().catch(e=>console.warn(e));

    generateBtn.disabled = true;
    stopBtn.disabled = false;
    downloadBtn.disabled = true;

    // auto stop on audio end
    audioEl.onended = ()=> stopRecording();
  });

  stopBtn.addEventListener('click', ()=> stopRecording());

  function stopRecording(){
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
    if (audioEl) audioEl.pause();
    if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
    generateBtn.disabled = false;
    stopBtn.disabled = true;
  }

  // helpers
  function formatFileSize(bytes){
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1048576) return (bytes/1024).toFixed(1) + ' KB';
    return (bytes/1048576).toFixed(2) + ' MB';
  }
  function formatTime(s){
    if (!isFinite(s)) return '-:--';
    const m = Math.floor(s/60), sec = Math.floor(s%60);
    return `${m}:${sec<10?'0':''}${sec}`;
  }

  // initial sizing
  resize();
  // small warm background
  ctx.fillStyle = '#020214';
  ctx.fillRect(0,0,canvas.width,canvas.height);
});
</script>
</body>
</html>
